"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SurrealSocket = void 0;
const types_js_1 = require("../types.js");
const node_js_1 = __importDefault(require("./WebSocket/node.js"));
const getIncrementalID_js_1 = require("./getIncrementalID.js");
const processUrl_js_1 = require("./processUrl.js");
class SurrealSocket {
    constructor({ url, onOpen, onClose, }) {
        Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "onOpen", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "onClose", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ws", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: types_js_1.WebsocketStatus.CLOSED
        });
        Object.defineProperty(this, "queue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "liveQueue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "unprocessedLiveResponses", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "ready", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resolveReady", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "closed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resolveClosed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "socketClosureReason", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                1000: "CLOSE_NORMAL",
            }
        });
        this.resolveReady = () => { }; // Purely for typescript typing :)
        this.ready = new Promise((r) => (this.resolveReady = r));
        this.resolveClosed = () => { }; // Purely for typescript typing :)
        this.closed = new Promise((r) => (this.resolveClosed = r));
        this.onOpen = onOpen;
        this.onClose = onClose;
        this.url = (0, processUrl_js_1.processUrl)(url, {
            http: "ws",
            https: "wss",
        }) + "/rpc";
    }
    open() {
        // Close any possibly connected sockets, reset status;
        this.close(1000);
        this.resetReady();
        // Connect to Surreal instance
        this.ws = new node_js_1.default(this.url);
        this.ws.addEventListener("open", (_e) => {
            this.status = types_js_1.WebsocketStatus.OPEN;
            this.resolveReady();
            this.onOpen?.();
        });
        this.ws.addEventListener("close", (_e) => {
            this.resolveClosed();
            this.resetClosed();
            Object.values(this.liveQueue).map((query) => {
                query.map((cb) => cb({
                    action: "CLOSE",
                    detail: "SOCKET_CLOSED",
                }));
            });
            this.queue = {};
            this.liveQueue = {};
            this.unprocessedLiveResponses = {};
            // Connection retry mechanism
            if (this.status !== types_js_1.WebsocketStatus.CLOSED) {
                this.status = types_js_1.WebsocketStatus.RECONNECTING;
                setTimeout(() => {
                    this.open();
                }, 2500);
                this.onClose?.();
            }
        });
        this.ws.addEventListener("message", (e) => {
            const res = JSON.parse(e.data.toString());
            if ("method" in res && res.method === "notify") {
                this.handleLiveBatch(res.params);
            }
            else if (res.id && res.id in this.queue) {
                this.queue[res.id](res);
                delete this.queue[res.id];
            }
        });
    }
    // Extracting the pure object to prevent any getters/setters that could break stuff
    // Prevent user from overwriting ID that is being sent
    async send(method, params, callback) {
        await this.ready;
        const id = (0, getIncrementalID_js_1.getIncrementalID)();
        this.queue[id] = callback;
        this.ws?.send(JSON.stringify({ id, method, params }));
    }
    async listenLive(queryUuid, callback) {
        if (!(queryUuid in this.liveQueue))
            this.liveQueue[queryUuid] = [];
        this.liveQueue[queryUuid].push(callback);
        // Cleanup unprocessed messages queue
        await Promise.all(this.unprocessedLiveResponses[queryUuid]?.map(callback) ?? []);
        delete this.unprocessedLiveResponses[queryUuid];
    }
    async kill(queryUuid) {
        if (queryUuid in this.liveQueue) {
            this.liveQueue[queryUuid].forEach((cb) => cb({
                action: "CLOSE",
                detail: "QUERY_KILLED",
            }));
            delete this.liveQueue[queryUuid];
        }
        await new Promise((r) => {
            this.send("kill", [queryUuid], (_) => {
                if (queryUuid in this.unprocessedLiveResponses) {
                    delete this.unprocessedLiveResponses[queryUuid];
                }
                r();
            });
        });
    }
    async handleLiveBatch(messages) {
        await Promise.all(messages.map(async ({ query: queryUuid, ...message }) => {
            if (this.liveQueue[queryUuid]) {
                await Promise.all(this.liveQueue[queryUuid].map(async (cb) => await cb(message)));
            }
            else {
                if (!(queryUuid in this.unprocessedLiveResponses)) {
                    this.unprocessedLiveResponses[queryUuid] = [];
                }
                this.unprocessedLiveResponses[queryUuid].push(message);
            }
        }));
    }
    async close(reason) {
        this.status = types_js_1.WebsocketStatus.CLOSED;
        this.ws?.close(reason, this.socketClosureReason[reason]);
        this.onClose?.();
        await this.closed;
    }
    get connectionStatus() {
        return this.status;
    }
    resetReady() {
        this.ready = new Promise((r) => (this.resolveReady = r));
    }
    resetClosed() {
        this.closed = new Promise((r) => (this.resetClosed = r));
    }
}
exports.SurrealSocket = SurrealSocket;
//# sourceMappingURL=SurrealSocket.js.map